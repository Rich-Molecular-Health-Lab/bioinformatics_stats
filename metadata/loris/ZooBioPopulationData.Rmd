---
title: "Population Data Management Lab"
author: "Alicia Rich"
output:
  html_document:
    theme:
      bootswatch: litera
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    code_folding: "hide"
    fig_caption: true
    df_print: paged
params:
  course: "zoobio"
  semester: "spring25"
  group: "NoAnimalDeserted"
  
---

```{r, include = FALSE}
library(knitr)
library(conflicted)
library(downloadthis)
library(fontawesome)
library(glue)
library(ggplot2)
library(ggtext)
library(heatmaply)
library(here)
library(htmltools)
library(htmlwidgets)
library(kableExtra)
library(kinship2)
library(paletteer)
library(pedtools)
library(pedsuite)
library(plotly)
library(reactable)
library(reactablefmtr)
library(rmarkdown)
library(scales)
library(shiny)
library(showtext)
library(thematic)
library(tidyverse)
library(tippy)
library(usethis)
library(visNetwork)


conflicts_prefer(here::here)
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
conflicts_prefer(dplyr::left_join)
conflicts_prefer(dplyr::inner_join)
conflicts_prefer(dplyr::full_join)
conflicts_prefer(dplyr::semi_join)
conflicts_prefer(dplyr::rename)
conflicts_prefer(ggplot2::margin)
conflicts_prefer(ggplot2::theme_classic)
conflicts_prefer(ggplot2::ggplot)
conflicts_prefer(ggplot2::theme_minimal)
conflicts_prefer(ggplot2::aes)
conflicts_prefer(dplyr::lag)
conflicts_prefer(purrr::set_names)
conflicts_prefer(purrr::flatten)
conflicts_prefer(purrr::discard_at)
conflicts_prefer(base::which.max)
conflicts_prefer(lubridate::month)
conflicts_prefer(lubridate::year)
conflicts_prefer(lubridate::day)
conflicts_prefer(base::as.data.frame)
conflicts_prefer(htmltools::p)
conflicts_prefer(purrr::discard)
conflicts_prefer(ribd::kinship)
conflicts_prefer(plotly::layout)

here::i_am("PopulationData.Rmd")

source("reactables.R")

theme_set(theme_classic())
thematic_rmd()
thematic_on(accent = "#8785B2FF", fg = "black")

opts_chunk$set(message = FALSE,
               warning = FALSE,
               echo    = TRUE,
               include = TRUE,
               eval    = TRUE,
               comment = "")

palette <- c("#D53288FF", "#DC8045FF", "#21B14BFF", "#008AC2FF", "#3F459BFF")

colors <- list(
  f = "#D53288FF",
  m = "#3F459BFF",
  u = "#21B14BFF",
  sire = "#3F459B33",
  dam  = "#D5328833",
  emph = "#DC8045FF",
  seq  = "rcartocolor::Sunset",
  div  = "rcartocolor::Temps",
  rand = "khroma::stratigraphy"
)

deceased.col <- function(color) {
  gsub("FF", "33", color)
}

font_add_google("Noto Sans Symbols", family = "NotoSym")
showtext_auto()

```


# Format Studbook Data

## Inspect Spreadsheets in Excel

First, we need to read in our studbook data and clean it up to create a *tidy* format of one master table.

1.  Open the file `Studbook_Living.csv` and make sure it has the following columns with the exact names listed.

- It is fine if you have extra columns, and all the columns may be in any order, but your spreadsheet must include at least these columns with the exact name syntax:
  - `ID`
    - *This is the studbook ID (not the `LocalID`, if your spreadsheet has one)*
  - `Sex`
  - `Sire`
  - `Dam`
  - `Event_Type`
    - *This column will have values like `Birth/Hatch` or `Transfer`*
  - `Date`
    - *This will be the date for the event on each row. If you have another column for something like birth date, just make sure this general date column is the only one with this name.*
  - `Location`
    - *The same comments from Date apply here. This should be the location corresponding to the event of each row.*
- Rename any columns as necessary, re-save as a `.csv`, and proceed.

2.  Repeat the same for the file `Studbook_Historic.csv` using the same list of columns.

## Read Data into R

Now check the format of the dates in your files. 

- If your dates are formatted like the following:

```
1/1/2003
```

  - or like this:

```
16-Mar-08
```

  - Then run the first chunk labeled as `DateA`.  
  
- If your dates are formatted like the following:

```
May 11, 2016
```

  - Then run the second chunk labeled as `DateB`.

### DateA

```{r}
source("DatesA.R")
```


### DateB

```{r}
source("DatesB.R")
```


## Continue Formatting Data

```{r}
births <-  studbook.living %>%
  bind_rows(studbook.historic) %>% distinct() %>%
  filter(str_detect(Event_Type, "Birth|Hatch|Capture")) %>%
  arrange(ID, Event_order) %>%
  group_by(ID) %>% 
  arrange(Date, .by_group = TRUE) %>%
  fill(Date, .direction = "downup") %>% 
  ungroup() %>%
  arrange(ID) %>%
  fill(Date, .direction = "downup") %>%
  group_by(ID) %>% slice_min(Event_order) %>%
  ungroup() %>% arrange(Location, ID, Dam) %>%
  arrange(Location, ID) %>%
  mutate(Sire = as.integer(str_extract(Sire, "\\d+")),
         Dam  = as.integer(str_extract(Dam, "\\d+"))) %>%
  select(ID, Sex, Sire, Dam, Birth_Date = Date, Birth_Location = Location)

transfers.deaths  <-  studbook.living %>%
  bind_rows(studbook.historic) %>% distinct() %>%
  filter(str_detect(Event_Type, "Transfer|LTF|Death")) %>%
  arrange(ID, Event_order) %>%
  group_by(ID) %>% fill(Date, .direction = "downup") %>%
  slice_max(Event_order) %>% ungroup() %>%
  mutate(Status = if_else(Event_Type == "Transfer", "Alive", "Deceased")) %>%
  select(ID, Last_Date = Date, Last_Location = Location, Status)

stud <- births %>%
  left_join(transfers.deaths) %>%
  distinct() %>%
  mutate(Status        = replace_na(Status, "Alive"),
         Last_Date     = if_else(is.na(Last_Date)    , Birth_Date    , Last_Date),
         Last_Location = if_else(is.na(Last_Location), Birth_Location, Last_Location)) %>%
  arrange(ID) %>%
  mutate(sex_num = case_when(Sex == "Male"   ~ 1,
                             Sex == "Female" ~ 2,
                             .default = 3),
         across(c("ID", "Sire", "Dam"), ~ as.character(.))) %>%
  mutate(Sire = if_else(is.na(Sire) & !is.na(Dam ), 
                        as.character(str_glue("999", "{Dam}" )), 
                        Sire),
         Dam  = if_else(is.na(Dam)  & !is.na(Sire), 
                        as.character(str_glue("999", "{Sire}")), 
                        Dam )) %>%
  mutate(across(c("Sire", "Dam"), ~ replace_na(., "")))
```


```{r}
missing <- fixParents(
  id       = stud$ID,
  dadid    = stud$Sire,
  momid    = stud$Dam,
  sex      = stud$sex_num
) %>%
  select(ID      = id,
         Sire    = dadid,
         Dam     = momid,
         sex_num = sex) %>%
  filter(ID != "0") %>%
  anti_join(stud, by = join_by(ID, Sire, Dam, sex_num)) %>% 
  distinct()

sires <- missing %>% filter(sex_num == 1) %>%
  left_join(select(stud, 
                   offspring     = ID, 
                   ID            = Sire, 
                   mateID        = Dam,
                   Last_Date     = Birth_Date,
                   Last_Location = Birth_Location), 
            by = join_by(ID))

dams <- missing %>% filter(sex_num == 2) %>%
  left_join(select(stud, 
                   offspring     = ID, 
                   ID            = Dam, 
                   mateID        = Sire,
                   Last_Date     = Birth_Date,
                   Last_Location = Birth_Location), 
            by = join_by(ID))
```

```{r}
locations <- c(pull(studbook.historic, Location), 
               pull(studbook.living  , Location),
               pull(births           , Birth_Location),
               pull(transfers.deaths , Last_Location)) %>%
  unique() %>%
  enframe(name = NULL, value = "Location") %>%
  arrange(Location) %>%
  mutate(label   = str_sub(Location, 1L, 3L),
         str_end = str_sub(Location, -1L, -1L)) %>%
  mutate(label   = if_else(row_number(.) > 1 & str_equal(label, lag(label)), 
                           str_replace(label, "\\w$", str_end), 
                           label)) %>%
  select(label, Location)

location.key <- sample(palettes_d$palettesForR$Cranes, 
                       size = length(unique(locations$label)), 
                       replace = FALSE) %>%
  as.list() %>%
  set_names(., map(as.list(unique(locations$label)), \(x) paste0(x))) %>%
  enframe(name = "label", value = "loc_color") %>%
  right_join(locations, by = join_by(label))
```

```{r}
studbook <- bind_rows(sires, dams) %>%
  arrange(ID, offspring, mateID) %>%
  distinct() %>%
  group_by(ID) %>%
  mutate(Birth_Date = (min(Last_Date)) - years(2)) %>%
  slice_max(order_by = Last_Date, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(-c(offspring, mateID)) %>%
  mutate(Status         = "Deceased", 
         Birth_Location = "UNDETERMINED",
         Sex            = case_when(
           sex_num == 3 ~ "Undetermined",
           sex_num == 2 ~ "Female",
           sex_num == 1 ~ "Male"
         )) %>%
  bind_rows(stud) %>% distinct()  %>%
  mutate(Age = if_else(Status == "Alive", 
                       year(today())   - year(Birth_Date), 
                       year(Last_Date) - year(Birth_Date)),
         color = case_when(Sex == "Female"          ~ colors$f,
                           Sex == "Male"            ~ colors$m,
                           Sex == "Undetermined"    ~ colors$u),
         yr_birth = year(Birth_Date),
         yr_last  = year(Last_Date),
         sex_num = if_else(sex_num == 3, 0, sex_num)) %>%
  left_join(location.key, by = join_by(Last_Location == Location)) %>%
  mutate(Last_Location  = as.character(label), 
         Last_loc_color = as.character(loc_color)) %>%
  select(-c(label, loc_color)) %>%
  left_join(location.key, by = join_by(Birth_Location == Location)) %>%
  mutate(Birth_Location  = as.character(label), 
         Birth_loc_color = as.character(loc_color)) %>%
  select(-c(label, loc_color)) %>%
  mutate(Sire = if_else(is.na(Sire) | Sire == "", "0", Sire),
         Dam  = if_else(is.na(Dam)  | Dam == "" , "0", Dam))  %>% 
  arrange(ID) %>%
  mutate(ID = as.character(ID)) %>% distinct()

living   <- filter(studbook, Status == "Alive")    %>% pull(ID) %>% as.character()
deceased <- filter(studbook, Status == "Deceased") %>% pull(ID) %>% as.character()
```


## View Formatted File

Let's take a glimpse of our formatted studbook now.

```{r, out.width="100%"}
studbook.tbl <- studbook %>%
  select(
    Status, 
    ID,      
    Sex,
    color,
    Birth_Date,
    yr_birth,
    Birth_Location,
    Birth_loc_color,
    Sire  ,     
    Dam   ,
    Age,
    Last_Date,
    yr_last,
    Last_Location,
    Last_loc_color
  ) %>% 
  studbook.react(., studbook.cols(.), groupBy = "Status")

save_reactable_test(studbook.tbl, paste0("StudbookA_", params$group, ".html"))
studbook.tbl
```


# Population Viability Analysis

## Demographic Trends

Let's look at the basic population size over time to begin quantifying growth rate and assessing overall population viability.

```{r}
max_month <- floor_date(today(), "month")
max_year  <- floor_date(today(), "year")

MonthCounts <- list(Birth_Date = pull(studbook, Birth_Date), 
                    Status     = pull(studbook, Status), 
                    Last_Date  = pull(studbook, Last_Date))
FemaleCounts <- list(
                    Birth_Date = pull(filter(studbook, sex_num == 2), Birth_Date), 
                    Status     = pull(filter(studbook, sex_num == 2), Status), 
                    Last_Date  = pull(filter(studbook, sex_num == 2), Last_Date))
MaleCounts <- list(
                    Birth_Date = pull(filter(studbook, sex_num == 1), Birth_Date), 
                    Status     = pull(filter(studbook, sex_num == 1), Status), 
                    Last_Date  = pull(filter(studbook, sex_num == 1), Last_Date))
UndetCounts <- list(
                    Birth_Date = pull(filter(studbook, sex_num == 0), Birth_Date), 
                    Status     = pull(filter(studbook, sex_num == 0), Status), 
                    Last_Date  = pull(filter(studbook, sex_num == 0), Last_Date))

monthly_counts.f <- pmap(FemaleCounts, function(Birth_Date, Last_Date, Status) {
  if (is.na(Birth_Date)) return(NULL)
  
  start_month <- floor_date(Birth_Date, "month")
  
  if (Status == "Alive") {
    end_month <- max_month
  } else if (is.na(Last_Date) & Status == "Deceased") {
    return(NULL)
  } else {
    end_month <- floor_date(Last_Date, "month")
  }
  
  # Check if start_month is after end_month; if so, return NULL
  if (start_month > end_month) return(NULL)
  
  # Otherwise, return the sequence as a list
  as.list(seq(start_month, end_month, by = "months"))
}) %>%
  list_flatten() %>%
  list_c() %>%
  tibble(Date = .) %>%
  group_by(Date) %>%
  summarize(Females = n()) %>%
  ungroup()

monthly_counts.m <- pmap(MaleCounts, function(Birth_Date, Last_Date, Status) {
  if (is.na(Birth_Date)) return(NULL)
  
  start_month <- floor_date(Birth_Date, "month")
  
  if (Status == "Alive") {
    end_month <- max_month
  } else if (is.na(Last_Date) & Status == "Deceased") {
    return(NULL)
  } else {
    end_month <- floor_date(Last_Date, "month")
  }
  
  # Check if start_month is after end_month; if so, return NULL
  if (start_month > end_month) return(NULL)
  
  # Otherwise, return the sequence as a list
  as.list(seq(start_month, end_month, by = "months"))
}) %>%
  list_flatten() %>%
  list_c() %>%
  tibble(Date = .) %>%
  group_by(Date) %>%
  summarize(Males = n()) %>%
  ungroup()


monthly_counts.u <- pmap(UndetCounts, function(Birth_Date, Last_Date, Status)  {
    if (is.na(Birth_Date)) return(NULL)
    start_month <- floor_date(Birth_Date, "month")
        if (Status == "Alive") {
      end_month <- max_month
    } else if (is.na(Last_Date) & Status == "Deceased") {
      return(NULL)
    } else {
      end_month <- floor_date(Last_Date, "month")
    }
    return(as.list(seq(start_month, end_month, by = "months")))
}) %>%
  list_flatten() %>%
  list_c() %>%
  tibble(Date = .)  %>%
  group_by(Date) %>%
  summarize(Undetermined = n()) %>% ungroup()

monthly_counts <- pmap(MonthCounts, function(Birth_Date, Last_Date, Status) {
  if (is.na(Birth_Date)) return(NULL)
  
  start_month <- floor_date(Birth_Date, "month")
  
  if (Status == "Alive") {
    end_month <- max_month
  } else if (is.na(Last_Date) & Status == "Deceased") {
    return(NULL)
  } else {
    end_month <- floor_date(Last_Date, "month")
  }
  
  # Check if start_month is after end_month; if so, return NULL
  if (start_month > end_month) return(NULL)
  
  # Otherwise, return the sequence as a list
  as.list(seq(start_month, end_month, by = "months"))
}) %>%
  list_flatten() %>%
  list_c() %>%
  tibble(Date = .)  %>%
  group_by(Date) %>%
  summarize(Population = n()) %>% ungroup() %>%
  left_join(monthly_counts.u) %>%
  left_join(monthly_counts.f) %>%
  left_join(monthly_counts.m) %>%
  mutate(across(where(is.numeric), ~ replace_na(., 0))) %>%
  mutate(annotate = if_else(Population == max(Population), "N Max", NA))
```


```{r, out.width="100%"}
fills <- map_depth(colors, 1, \(x) gsub("FF", "33", x))
plot.population <- plot_ly(monthly_counts,
                           mode        = "lines",
                           type        = "scatter",
                           stackgroup  = "one",
                           x           = ~Date, 
                           y           = ~Undetermined,
                           name        = "Undetermined",
                           legendgroup = "By Sex",
                           mode        = "lines",
                           line        = list(color = colors$u),
                           fillcolor   = fills$u
                           ) %>%
                 add_trace(x           = ~Date, 
                           y           = ~Females,
                           name        = "Females",
                           legendgroup = "By Sex",
                           mode        = "lines",
                           stackgroup  = "one",
                           line        = list(color = colors$f),
                           fillcolor   = fills$f
                           ) %>%
                 add_trace(x           = ~Date, 
                           y           = ~Males,
                           name        = "Males",
                           legendgroup = "By Sex",
                           mode        = "lines",
                           stackgroup  = "one",
                           line        = list(color = colors$m),
                           fillcolor   = fills$m
                           )   %>%
                 add_trace(x           = ~Date, 
                           y           = ~Population,
                           name        = "Total count",
                           legendgroup = "Total",
                           mode        = "lines",
                           stackgroup  = "one",
                           line        = list(color = colors$emph),
                           fillcolor   = fills$emph
                           )  %>%
                 plotly::layout(showlegend = T, 
                                title      = "Population Growth over Time",
                                yaxis      = list(title = "Count"),
                                xaxis      = list(rangeslider = list(visible = T)))

plot.population <- plot.population %>%
  plotly::layout(
         xaxis = list(zerolinecolor = "#fffff",
                      zerolinewidth = 1,
                      gridcolor     = "#fffff",
                      showgrid = F),
         yaxis = list(zerolinecolor = "#fffff",
                      zerolinewidth = 1,
                      showgrid = F),
         plot_bgcolor = "#ffffff", 
         width        = 900)


saveWidget(plot.population, paste0("PopulationGrowth_", params$group, ".html"))
plot.population
```


Now we will zoom out to annual population counts to follow the standard method for computing a normalized rate of growth over the past 5 years compared to all years.

```{r}
YearCounts  <- list(Birth_Date = pull(studbook, Birth_Date), 
                    Status     = pull(studbook, Status), 
                    Last_Date  = pull(studbook, Last_Date))

alive_years <- pmap(YearCounts, function(Birth_Date, Last_Date, Status) {
  if (is.na(Birth_Date)) return(NULL)
  
  start_year <- floor_date(Birth_Date, "year")
  
  if (Status == "Alive") {
    end_year <- max_year
  } else if (is.na(Last_Date) & Status == "Deceased") {
    return(NULL)
  } else {
    end_year <- floor_date(Last_Date, "year")
  }
  
  # Check if start_month is after end_month; if so, return NULL
  if (start_year > end_year) return(NULL)
  
  # Otherwise, return the sequence as a list
  as.list(seq(start_year, end_year, by = "years"))
})


annual_counts <- list_flatten(alive_years) %>%
  list_c() %>%
  tibble(Year = .)  %>%
  group_by(Year) %>%
  summarize(Count = n()) %>% ungroup()


growth_rates <- annual_counts$Count[-1] / annual_counts$Count[-length(annual_counts$Count)]

last_5_growth <- tail(growth_rates, 5)

lambda  <- prod(last_5_growth)^(1/length(last_5_growth))

lambda2 <- exp(mean(log(last_5_growth)))
```


## Construct Pedigree

Now we will use a package called `pedtools` to create our pedigree objects. If the chunk below runs without any errors, then you should see `pedig` appear as an object listed in your environment.

```{r}
pedig <- ped(
  id     = studbook$ID,
  fid    = studbook$Sire,
  mid    = studbook$Dam,
  sex    = studbook$sex_num
) 
```


The object `pedig` most likely contains a list of multiple pedigree objects, as any founders or lineages not represented in the current living population will form discrete, disconnected trees. There also will probably be several "singletons" which are founders without any connections to the living population. Run the code below to thin out your dataset by ignoring the founders that never reproduced.

```{r}
pedig <- discard(pedig, \(x) pedsize(x) <= 1)
```

### Pedigree Plot

Now we will take a look at your data in the form of the traditional pedigree structures we covered in class. The code below will prepare some formatting variables to assign color-coding before plotting the pedigree(s) you already created.

```{r, out.width="100%", dev='svg'}
female   <- living %>% intersect(females(pedig))
male     <- living %>% intersect(males(pedig))
undet    <- living %>% setdiff(males(pedig)) %>% setdiff(females(pedig))

female.d   <- deceased %>% intersect(females(pedig))
male.d     <- deceased %>% intersect(males(pedig))
undet.d    <- deceased %>% setdiff(males(pedig)) %>% setdiff(females(pedig))

plot_pedigrees <- function(pedigree, name, ...) {
plot(pedigree,
     title        = paste0(name),
     cex          = 0.4,
     deceased     = deceased,
     labs         = NULL,
     fill         = fills, 
     lwd          = 0.3,
     col          = "black",
     pty          = "m", ...)
}

      fills  <- list(c(female), c(male), c(undet))
names(fills) <- keep_at(colors, c("f", "m", "u"))
  ped.fills  <- list("#D5328870" = c(female.d), "#3F459B70" = c(male.d), "#21B14B70" = c(undet.d))
      fills  <- list_assign(fills, !!!ped.fills)

```

```{r, out.width="100%", dev='svg'}
plots <- imap(pedig, \(x, idx) plot_pedigrees(x, idx))
```
Most of you probably still have multiple plots, one of which looks much more complicated than the others. We can thin our dataset out even more by filtering for just those individuals still represented in the living population. That means we want to set aside any of the lineages where the descendants are no longer related to any living individuals through surviving siblings, offspring, nieces, nephews, etc. In most cases, that will leave us with one large and complicated pedigree representing all the contemporary diversity in our population.\n
\n
You should inspect the plots about and decide which one to carry forward for your analysis, based on this concept. Once you have done so, update the `"_comp1"` in the code chunk below with the title of your chosen plot and then continue working forward.  

*Note: you can come back and run the code chunk again any time with a different name inserted, and all future steps will update based on that selection.*

```{r}
includes_living <- c("_comp1")
```


```{r, out.width="100%", dev='svg'}
ped.living  <- keep_at(pedig, includes_living)

ped.living <- ped.living[[1]]

famid(ped.living) <- "Current"

plot_pedigrees(ped.living, "Pedigree of Living Population")
```

### Better Pedigree Graphics

I don't love the pedtools graphics system and lack of customization/interactivity, so if we want to look more closely at the details of relationships and clustering across a complex pedigree, we can transfer the data produced by pedtools into some other visualization packages. In this case, we will use `visNetwork` Run the chunk below to generate the new, properly-formatted dataframes that this package requires to build the graphics.

```{r}
# Try to get generation numbers with "indiv" first
gen_numbers <- generations(ped.living, what = "indiv")

# If no generation numbers were returned, try an alternative method:
if (length(gen_numbers) == 0) {
  warning("No generation numbers returned using what = 'indiv'. Trying what = 'depth' instead.")
  gen_numbers <- generations(ped.living, what = "depth")
}

# If still empty, then assign NA for all individuals (or handle appropriately)
if (length(gen_numbers) == 0) {
  warning("No generation numbers found using either method; assigning NA to all individuals.")
  gen_numbers <- rep(NA_integer_, nrow(ped.living))
}

# Now, create the levels tibble using the computed generation numbers.
levels <- as.list(gen_numbers) %>%
  set_names(ped.living$ID) %>%     # ped.living$ID must have the same length as gen_numbers
  enframe(name = "id", value = "level") %>%
  mutate(level = as.integer(level)) %>%
  mutate(level = if_else(id %in% founders(ped.living), level, level + 2)) %>%
  mutate(level = if_else(id %in% leaves(ped.living), level + 1, level))

```


```{r}
pairs <- map(as.list(nonfounders(ped.living)), \(x) as.list(parents(ped.living, id = x))) %>%
  enframe(name = NULL) %>%
  unnest_wider(value, names_sep = "_") %>%
  distinct() %>%
  mutate(pid = paste0("0", as.character(row_number()))) %>%
  left_join(studbook, by = join_by(value_1 == Sire, value_2 == Dam)) %>%
  select(pid, fid = value_1, mid = value_2, color = Birth_loc_color, label = Birth_Location) %>% 
  distinct() %>% 
  group_by(pid) %>% 
  summarize(across(everything(), ~ dplyr::first(.x)), .groups = "drop") %>% 
  ungroup()

sire <- pull(pairs, fid, pid) %>% as.list()
dam  <- pull(pairs, mid, pid) %>% as.list()

pairs.edf <- pairs  %>%
  pivot_longer(cols = c("fid", "mid"), values_to = "from", names_to = NULL) %>%
  select(from, to = pid, color) %>%
  mutate(dashes = TRUE, 
         shadow = FALSE,
         width  = 0.5,
         arrows = "to")

combined <- c(sire, dam)

# Group by names and merge the values into a single vector for each unique name.
combined_grouped <- split(combined, names(combined)) %>% 
  map(unlist)

# Now use combined_grouped in place of list_merge(sire, !!!dam)
offspring.edf <- combined_grouped %>%
  imap(function(x, idx) {
    list(idx, as.list(commonDescendants(ped.living, ids = x, maxGen = 2)))
  }) %>%
  enframe(name = NULL, value = "id") %>%
  unnest_wider(id, names_sep = "_") %>%
  unnest_longer(id_2, values_to = "id") %>%
  select(from = id_1, to = id) %>%
  arrange(from, to) %>%
  distinct() %>%
  left_join(select(pairs, from = pid, color), by = join_by(from)) %>%
  mutate(dashes = FALSE, 
         shadow = TRUE,
         width  = 0.7,
         arrows = NULL)


edges <- bind_rows(pairs.edf, offspring.edf)

pairs.ndf <- pairs  %>%
  pivot_longer(cols = c("fid", "mid"), values_to = "mateID", names_to = NULL) %>%
  left_join(levels, by = join_by(mateID == id)) %>%
  group_by(pid, color, label) %>%
  mutate(level = sum(max(level), 1)) %>% ungroup() %>% 
  group_by(pid) %>% 
  summarize(across(everything(), ~ dplyr::first(.x)), .groups = "drop") %>% 
  ungroup() %>%
  mutate(
    group = "pair",
    shape = "icon",
    icon  = map(color, \(x) list(code = "\uf068", color = x, face = "'Font Awesome 5 Free'", weight = 700, size = 35)),
    font  = map(color, \(x) list(size = 18, color = x, strokeColor = "#FFFFFF", strokeWidth = 3))
  ) %>%
  select(id = pid, level, group, shape, icon, label, font) %>%
  distinct()
```


```{r}
nodes <- as.data.frame(ped.living) %>% 
  mutate(id    = as.character(id),
         group = as.character(sex)) %>% 
  select(id, group) %>% 
  group_by(id) %>% 
  summarize(across(everything(), ~ dplyr::first(.x)), .groups = "drop") %>% 
  ungroup() %>% 
  left_join(levels, by = join_by(id)) %>% 
  group_by(id) %>% 
  summarize(across(everything(), ~ dplyr::first(.x)), .groups = "drop") %>% 
  ungroup() %>% 
  mutate(color = case_when(
           group == "0" ~ colors$u,
           group == "1" ~ colors$m,
           group == "2" ~ colors$f),
         code = case_when(
           group == "0" ~ "\uf04b",
           group == "1" ~ "\uf0c8",
           group == "2" ~ "\uf111"),
         shape = "icon",
         label = id
         ) %>% 
  mutate(icon = map2(color, code, \(x, y) list(code = y, 
                                               color = x, 
                                               face = "'Font Awesome 5 Free'",
                                               weight = 700, 
                                               size = 30)),
         font = map(color, \(x) list(size = 12, 
                                     color = x, 
                                     strokeColor = "#FFFFFF", 
                                     strokeWidth = 3))
         ) %>% 
  select(id, level, group, shape, icon, label, font) %>% 
  bind_rows(pairs.ndf) %>% 
  distinct(id, .keep_all = TRUE) %>% 
  ungroup()
```

Now we are ready to build the actual graphics below. The code below will render two different visualizations for you.

#### Hierarchical Layout

First, you will generate a hierarchical plot that resembles the traditional pedigree structure above. Note that the horizontal-bar icons represent each mother-father pair with one or more shared offspring. The dotted lines lead from each parent to the icon representing their parental unit, with color-coding and labels corresponding to the institution where the pair produced their shared offspring. The solid lines coming from each bar-icon connect the parental unit to the offspring that would be full-siblings.

>Note: these plots depend on some more memory-intensive javascript code, so you will experience more of a delay than usual before the image loads. If you see a blank plotting area at first, just wait a few minutes for the image to appear.

```{r, out.width="100%"}
locations.color <- function(x) {
  list_assign(x, color = "#444444")
}

legend <- nodes %>%
  select(group, shape, icon) %>%
  distinct() %>%
  mutate(icon = if_else(group %in% c("0", "1", "2"), icon, map(icon, \(x) locations.color(x)))) %>%
  mutate(label = case_when(
    group == "0" ~ "Sex Undet",
    group == "1" ~ "Male",
    group == "2" ~ "Female",
    .default = "Pair colored/labeled by Location"
    )) %>% distinct()

ped.net <- visNetwork(nodes, edges, width = "100%", height = "700px") %>% 
  addFontAwesome(version = "5.13.0") %>%
  visNodes(shadow = TRUE, fixed  = list(x = FALSE, y = FALSE))  %>%
  visInteraction(dragNodes = TRUE, dragView = TRUE) %>%
  visLegend(addNodes = legend, ncol = 1, useGroups = FALSE)

  
ped.vert <- ped.net %>%
  visHierarchicalLayout(direction = "UD", shakeTowards = "roots") %>%
  visLegend(addNodes = legend, ncol = 1, useGroups = FALSE)
  

ped.vert

visSave(ped.net, file = paste0("Pedigree_Hierarchical_", params$group, ".html"))
```


#### Network Layout

Second, you will view the same plot as a network instead of a hierarchy. This gives a clearer representation of the clustering around particularly successful mated pairs and institutions.

>Note: this one takes even longer to load than the previous plot.

```{r, out.width="100%"}
ped.net

visSave(ped.net, file = paste0("Pedigree_Network_", params$group, ".html"))
```


## Generate Detailed Pedigree Statistics

Next, we will generate some of the descriptive statistics that we can use to assess the long-term viability of our populations and make some breeding recommendations.

### Founders Represented

We will need information about founders still represented in the living population, so run the code below.

```{r}
founder.descendants <- map(as.list(founders(pedig)), \(x) as.list(descendants(pedig, x, inclusive = TRUE))) %>%
  compact()
names(founder.descendants) <- map(founder.descendants, \(x) x[[1]])

founderReps <- keep(founder.descendants, function(sublist) {
  flat <- unlist(sublist)
  any(flat %in% living)
}) %>% list_flatten(name_spec = "") %>% unique() %>%
  intersect(founders(ped.living))

n_founder_reps <- length(founderReps)

founderRepsIDs <- founderReps %>% list_c()

dp <- descentPaths(ped.living)

founderContribution <- map_dbl(founders(ped.living), function(f) {
  paths_list <- dp[[f]]
  valid_paths <- keep(paths_list, ~ tail(.x, 1) %in% living)
  sum(map_dbl(valid_paths, ~ 0.5^(length(.x) - 1)))
})
names(founderContribution) <- founders(ped.living)

p <- founderContribution / sum(founderContribution)
```

#### Summary Table

We are going to carry those calculations forward for some other analyses, but first, let's put them into a summary table and look at the studbook again, this time just focusing on the founders still represented by descendants in the living population.

```{r, out.width="100%"}
p.tbl <- enframe(p, name = "ID", value = "Rel_Contribution")

founder.summary <- enframe(founderContribution, 
                           name = "ID", 
                           value = "Contribution") %>%
  left_join(p.tbl) %>%
  left_join(studbook) %>%
  select(
         ID, 
         Birth_Location, 
         Sex, 
         Birth_Date, 
         Age_Death = Age, 
         Death     = Last_Date, 
         Last_Location,
         Rel_Contribution,
         color         ,
         yr_birth      ,
         yr_last       ,
         Birth_loc_color ,
         Last_loc_color  
         )  %>%
  arrange(Last_Location, desc(Rel_Contribution))

founder.vis <- founder.summary %>%
  studbook.react(., cols = founder.cols(.))

save_reactable_test(founder.vis, paste0("StudbookB_", params$group, ".html"))

founder.vis
```

### Contemporary Population 

Now we will generate some additional stats to give us a similar glimpse of the historical lineage, current representation, and breeding success of our living population.

#### Inbreeding Coefficients

We will use the pedigree object to calculate an **inbreeding coefficient** for each individual in the living population. Recall the definition of inbreeding coefficients:

>The autosomal inbreeding coefficient of a pedigree member is defined as the probability that, at a random autosomal locus, the **two alleles carried by the member are identical by descent** relative to the pedigree.
>>*It follows from the definition that the inbreeding coefficient of a non-founder equals the kinship coefficient of the parents.*


```{r}
inbred.ped <- inbreeding(ped.living) %>% 
  enframe(name = "ID", value = "inbred")

inbred.ped
```

#### Kinship Coefficients

This gives us some information about each individual's genetic history, especially their potential to contribute more/less genetic diversity to the next generation, but what does that mean when they are matched to an individual with a higher/lower inbreeding coefficient? When we match individuals, two individuals with moderate inbreeding coefficients but little shared ancestory might still have a positive or neutral impact on the population's long-term viability. That is why we will also calculate a pairwise metric to score each potential match - the **kinship coefficient**:

>For two (possibly equal) members A, B of a pedigree, their autosomal (resp. X-chromosomal) kinship coefficient is defined as the probability that a **random allele from A and a random allele from B, sampled at the same autosomal (resp. X-chromosomal) locus, are identical by descent** relative to the pedigree.

```{r}
kinship.ped    <- kinship(ped.living)
living.ped     <- intersect(living, rownames(kinship.ped))
living.kinship <- kinship.ped[living.ped, living.ped]
```

#### Other Summary Stats

We can also extract some basic counts from our pedigree for each individual before we create some visual summaries below.

```{r, out.width="100%"}
living_gen  <- gen_numbers[names(gen_numbers) %in% living]
generations <- enframe(gen_numbers, name = "ID", value = "Generations") %>%
  mutate(ID = as.character(ID))

ancestors <- as.list(rownames(living.kinship)) %>%
  set_names(map(., \(x) x)) %>%
  map(., \(x) as.list(ancestors(ped.living, x))) %>%
  enframe(name = "ID", value = "Ancestors")

children <- as.list(rownames(living.kinship)) %>%
  set_names(map(., \(x) x)) %>%
  map(., \(x) as.list(children(ped.living, x))) %>%
  enframe(name = "ID", value = "Children")

descendants <- as.list(rownames(living.kinship)) %>%
  set_names(map(., \(x) x)) %>%
  map(., \(x) as.list(descendants(ped.living, x))) %>%
  enframe(name = "ID", value = "Descendants")

siblings <- as.list(rownames(living.kinship)) %>%
  set_names(map(., \(x) x)) %>%
  map(., \(x) as.list(siblings(ped.living, x))) %>%
  enframe(name = "ID", value = "Siblings")

living.data <- ancestors %>% 
  left_join(descendants) %>% 
  left_join(children) %>% 
  left_join(siblings) %>%
  left_join(generations) %>%
  rowwise() %>%
  mutate(N_Children    = length(Children),
         N_Descendants = length(Descendants),
         N_Siblings    = length(Siblings),
         N_Ancestors   = length(Ancestors)) %>%
  select(ID, starts_with("N_")) %>%
  left_join(inbred.ped) %>%
  left_join(studbook) %>%
  select(Current_Location = Last_Location,
         Last_loc_color,
         Sex,
         ID, 
         Age,
         Sire,
         Dam,
         Birth_Date,
         Birth_Location,
         Birth_loc_color,
         color         ,
         yr_birth      ,
         yr_last       ,
         inbred,
         starts_with("N_")) %>%
  arrange(Current_Location, Sex, Age)

living.summary <- living.data %>%
  studbook.react(., cols = living.cols(.), 
                 groupBy      = "Current_Location",
                 columnGroups = living.groups)

save_reactable_test(founder.vis, paste0("StudbookC_", params$group, ".html"))

living.summary
```

### Overall Relatedness and Kinship

Now we will use some of the demographic stats we already computed to begin modeling our expected patterns in relatedness and inbreeding across the living population. First, we need to create a matrix representing every living pair's kinship coefficient. We will return to these pairwise relationships soon, but for now we will use it to compute our population-level statistics.

```{r}
mean_gen  <- mean(living_gen, na.rm = TRUE)
F_vec     <- 2 * diag(kinship.ped) - 1
F_mean    <- mean(F_vec)
delta_F   <- 1 - (1 - F_mean)^(1/mean_gen)
Ne        <- 1 / (2 * delta_F)
N         <- length(living)
Ne_over_N <- Ne / N
FGE       <- 1 / sum(p^2)
GD        <- 1 - sum(p^2)
MK        <- mean(living.kinship[upper.tri(living.kinship)])
F_vec     <- 2 * diag(living.kinship) - 1
F_mean    <- mean(F_vec)
```

#### Visualize Summary Table

Now you can view a summary of the statistics we just calculated and compare them to the summaries provided in the Pygmy Loris BTP. Use this table and the figures compiled so far to write your own version of a summary (1-2 paragraphs max) like the example.

```{r, out.width="100%"}
pva.summary <- tibble(N, 
                      n_founder_reps, 
                      FGE, 
                      delta_F, 
                      Ne, 
                      Ne_over_N, 
                      mean_gen, 
                      lambda2, 
                      F_mean, 
                      MK, 
                      GD) %>%
  mutate(across(where(is.numeric), ~round(., digits = 3))) %>%
  reactable(theme   = minty(font_size = 17),
            columns = pva.cols)


save_reactable_test(pva.summary, paste0("PVA_", params$group, ".html"))

pva.summary
```


## Pairwise Relationships

### All Living Individuals

Now let's look more closely at pairwise patterns in relatedness across our living population. The code below will generate a table with one row for every potential living pair in our population. Keep in mind that these are not necessarily potential breeding pairs, as we are mixing and matching male-male, male-female, and female-female pairs to get an over all impression of the living population's kinship patterns.

#### Pairwise Summary Stats

```{r}
coeff_living <- coeffTable(ped.living, 
                           coeff = c("f", "phi", "deg", "kappa")) %>%
  filter(id1 %in% living & id2 %in% living) %>%
  mutate(across(where(is.numeric), ~ round(., digits = 3))) %>%
  select(id1, 
         id2, 
         degree = deg, 
         inbred = f2, 
         phi, 
         kappa0 = k0, 
         kappa1 = k1, 
         kappa2 = k2)

coeff_living
```

We can also generate a demo table with expected values for typical patterns of kinship to help us interpret our results.

```{r}
example <- basicRelationships %>%
  mutate(across(where(is.numeric), ~ round(., digits = 3))) %>%
  select(label, relationship, phi, starts_with("kappa"))

example
```

#### Kinship Coefficients

It is much easier to visualize pairwise relationships as matrices or multidimensional plots. Let's create some graphical visualizations to interpret these stats. The plot below will give you a basic visualization of the overall patterns in relatedness between all living individuals in the current population.  Each cell will be colored by the pairwise kinshp coefficients we computed above.

```{r, out.width="100%"}
kin.plot <- heatmaply(
        living.kinship,
        dendrogram     = "none",
        main           = "Kinship Across Living Population",
        scale            = "none",
        colors           = paletteer_d(colors$div),
        margins          = c(60, 100, 40, 20),
        grid_color       = "white",
        grid_width       = 0.00001,
        label_format_fun = function(value) round(value, digits = 3),
        titleX           = TRUE,
        hide_colorbar    = FALSE,
        key.title        = "Kinship Coefficients",
        branches_lwd     = 0.1,
        fontsize_row     = 10, 
        fontsize_col     = 10,
        labCol           = colnames(living.kinship),
        labRow           = rownames(living.kinship),
        heatmap_layers   = theme(axis.line = element_blank())
        )

saveWidget(kin.plot, paste0("KinshipPlot_", params$group, ".html"))

kin.plot
```

### Matched Pairs

Finally, we want to look closer at potential breeding pairs to do some match-making, so let's generate some more pedigree statistics per individual and then visualize a plot of breeding pairs.

#### Kinship Coefficients

```{r, out.width="100%"}
living.m       <- filter(studbook, Status == "Alive" & Sex == "Male") %>% 
  mutate(ID = as.character(ID)) %>% 
  pull(ID)

living.f       <- filter(studbook, Status == "Alive" & Sex == "Female") %>% 
  mutate(ID = as.character(ID)) %>% 
  pull(ID)

annotate <- select(living.data, c(ID, starts_with("N_"))) %>%
  mutate(ID = as.character(ID)) %>%
  left_join(enframe(F_vec, name = "ID", value = "F_vec")) %>%
  left_join(studbook) %>%
  mutate(ID = as.character(ID),
    hoverText = str_glue(
    "{Last_Location}", "<br>", 
    "{Age}", " yrs (Born ", "{Birth_Date}", ")<br>",
    "Mother: ", "{Dam}", ", Father: ", "{Sire}", "<br>",
    "{N_Siblings}"," Siblings, ", "{N_Children}", " Offspring, ", "{N_Descendants}", " Descendants"
    )
  ) %>% arrange(ID)


living_males   <- intersect(living.m, rownames(living.kinship))
living_females <- intersect(living.f, rownames(living.kinship))

kinship_btp    <- living.kinship[living_males, living_females]

text_males   <- intersect(living.m, rownames(kinship_btp))
text_females <- intersect(living.f, colnames(kinship_btp))

annotate.m   <- filter(annotate, Status == "Alive" & Sex == "Male") %>% 
  select(ID, hoverText) %>%
  filter(ID %in% text_males) %>% 
  arrange(match(ID, text_males))

annotate.f   <- filter(annotate, Status == "Alive" & Sex == "Female") %>% 
  select(ID, hoverText) %>%
  filter(ID %in% text_females) %>% 
  arrange(match(ID, text_females))

hover_matrix <- outer(
  annotate.m$hoverText, 
  annotate.f$hoverText, 
  FUN = function(m_text, f_text) {
    I(paste0("<br>Male:<br>", m_text, "<br><br>",
           "Female:<br>", f_text))
  }
)

rownames(hover_matrix) <- annotate.m$ID
colnames(hover_matrix) <- annotate.f$ID

btp.plot <- heatmaply(
        kinship_btp,
        dendrogram       = "none", 
        xlab             = "Females", 
        ylab             = "Males",
        main             = "Kinship Values for Potential Mate Pairs",
        scale            = "none",
        colors           = paletteer_d(colors$div),
        margins          = c(60, 100, 40, 20),
        grid_color       = "white",
        grid_width       = 0.00001,
        label_format_fun = function(value) round(value, digits = 3),
        titleX           = TRUE,
        hide_colorbar    = FALSE,
        key.title        = "Kinship Vals",
        branches_lwd     = 0.1,
        fontsize_row     = 10, 
        fontsize_col     = 10,
        custom_hovertext = I(hover_matrix),
        heatmap_layers   = theme(axis.line = element_blank())
        )

saveWidget(btp.plot, paste0("BTPplot_", params$group, ".html"))

btp.plot
```

# Inspect Matches

Once you choose some potential pairs, you should plug their ID's into the code chunks below. This will give you a few more graphics to inspect their relationship. You can easily swap out different IDs and re-run the code chunks to see those revised results until you find the pairs you are happy with.

```{r}
male   <- c("2003") # Replace the number here with the ID number of your male of interest.
female <- c("1069") # Replace the number here with the ID number of your female of interest.

pair <- c(male, female)
```

## Kinship Coefficients

Let's produce our kinship heatmap again with clearer annotation for inspecting our proposed match more closely.

```{r, out.width="100%"}
celltext <- matrix("", nrow = nrow(kinship_btp), ncol = ncol(kinship_btp))
rownames(celltext) <- rownames(kinship_btp)
colnames(celltext) <- colnames(kinship_btp)

celltext[paste0(male), paste0(female)] <- "&#9733;"

btp.match.plot <- heatmaply(
        kinship_btp,
        dendrogram            = "none", 
        xlab                  = "Females", 
        ylab                  = "Males",
        main                  = "Kinship Values with Proposed Match",
        scale                 = "none",
        colors                = paletteer_d(colors$div),
        margins               = c(60, 100, 40, 20),
        grid_color            = "white",
        grid_width            = 0.00001,
        label_format_fun      = function(value) round(value, digits = 3),
        cellnote              = celltext,
        cellnote_textposition = "middle center",
        cellnote_size         = 16,
        titleX                = TRUE,
        hide_colorbar         = FALSE,
        key.title             = "Kinship Vals",
        branches_lwd          = 0.1,
        fontsize_row          = 10, 
        fontsize_col          = 10,
        heatmap_layers        = theme(axis.line = element_blank())
        )

saveWidget(btp.match.plot, paste0("BTP_match_plot_", params$group, ".html"))

btp.match.plot
```



## IBD and Kappa Coefficients

Now we are going to print something called a Kappa Triangle. This is a way to visualize the most probable identity by descent (IBD) for this pair in a 2-dimensional space.

```{r, out.width="100%"}
kappa.pair <- coeff_living %>%
  filter(xor((id1 == male   & id2 == female), 
             (id1 == female & id2 == male))) %>%
  select(id1, id2, kappa0, kappa1, kappa2)

kappa.tri <- showInTriangle(kappa.pair, plotType = "plotly")


saveWidget(kappa.tri, paste0("kappaTriangle_", params$group, ".html"))

print(kappa.pair)
kappa.tri
```

The red X mark represents the relationship between your hypothetical pair, while the letters in the graphic above are reference points for where different relationships would fall in that space. The summary table below contains a key for those abbreviations (and their associated values plotted here).

```{r}
print(example)
```

## Annotated Subplots for Match

Now we can reconstruct our network visualizations with clearer annotations to focus on our proposed pair.

```{r}

result  <- verbalise(ped.living, ids = pair)

related.pair <- setdiff(ped.living[["ID"]], 
                         c(unrelated(ped.living, male), 
                           unrelated(ped.living, female))) %>% unique()

connections <- edges %>%
  filter(to %in% c(pair, result[[1]][["v1"]], result[[1]][["v2"]])) %>%
  pull(from) %>% unique()

paths <- edges %>% 
  filter(to %in% c(related.pair, pair) | from %in% c(related.pair, pair)) %>%
  filter(to %in% c(pair, result[[1]][["v1"]], result[[1]][["v2"]], connections)) %>%
  mutate(color  = colors$emph,
         shadow = TRUE,
         width  = 3) %>%
  distinct()

pair.edges <- edges %>% 
  filter(to %in% c(related.pair, pair) | from %in% c(related.pair, pair)) %>%
  anti_join(paths) %>%
  bind_rows(paths) %>%
  distinct()

node.ids <- c(pull(pair.edges, from), pull(pair.edges, to)) %>% unique()

nodes.color <- function(group) {
  if (group == "match.m" | group == "match.f" | group == "match.anc") {
    list(background = colors$emph, border = "#000000")
  } else {
    list(NULL)
  }
  
}

icons.size <- function(x, group) {
  if (group == "match.m" | group == "match.f") {
    list_assign(x, size = 55, )
  } else if (group == "match.anc") {
    list_assign(x, size = 45)
  } else {
    return(x)
  }
}

font.match <- function(x, group) {
  if (group == "match.m" | group == "match.f") {
    list_assign(x, size = 18, background = colors$emph)
  } else if (group == "match.anc") {
    list_assign(x, size = 18, background = colors$emph)
  } else if (group == "match.rel.m" | group == "match.rel.f") {
    list_assign(x, size = 14)
  } else {
    return(x)
  }
}

pair.nodes <- filter(nodes, id %in% node.ids) %>%
  mutate(
    label = case_when(
      id %in% male                 ~ "Male Partner",
      id %in% female               ~ "Female Partner",
      id %in% result[[1]][["anc"]] ~ "Shared Ancestor",
      .default = label),
    group = case_when(
      id %in% male                 ~ "match.m",
      id %in% female               ~ "match.f",
      id %in% result[[1]][["anc"]] ~ "match.anc",
      id %in% result[[1]][["v1"]]  ~ "match.rel.m",
      id %in% result[[1]][["v2"]]  ~ "match.rel.f",
      .default = group)) %>%
  mutate(icon = map2(icon, group, \(x, y) icons.size(x, y)),
         font = map2(font, group, \(x, y) font.match(x, y)),
         color= map(group, \(x) nodes.color(x)),
         borderWidth = case_when(
           group %in% c("match.m"    , "match.f")     ~ 3,
           group %in% c("match.rel.m", "match.rel.f") ~ 1.5,
           group     == "match.anc"                   ~ 2,
           .default = 1
         ))

```

>Recall that these plots can be slower to load, but they should be quicker now that we are only working with a subplot.

Also, note that the subtitle of these plots now contains a printed summary produced by the `verbalise` package that is part of `pedsuite`.

```{r, out.width="100%"}
subtitle <- paste0(male, " & ", female, " are ", result[[1]][["rel"]],
                   "<br>Path Connecting Pair: ", result[[1]][["path"]])
pair.net <- visNetwork(pair.nodes, 
                       pair.edges, 
                       width   = "100%", 
                       height  = "700px",
                       main    = "Relatives of Proposed Match",
                       submain = subtitle) %>% 
  addFontAwesome(version = "5.13.0") %>%
  visNodes(shadow = TRUE, fixed  = list(x = FALSE, y = FALSE))  %>%
  visInteraction(dragNodes = TRUE, dragView = TRUE)
pair.vert <- pair.net %>%
  visHierarchicalLayout(direction = "UD", shakeTowards = "roots")

pair.vert
visSave(pair.vert, file = paste0("Pedigree_Hierarchical_PairLineage_", params$group, ".html"))

pair.net
visSave(pair.net, file = paste0("Pedigree_Network_PairLineage_", params$group, ".html"))
```


# Make your Plan and Report

Now you should use all the information provided to match at least one breeding pair for your new exhibit and add a paragraph in which you explain this choice and plan. 

- Run each chunk below to render a plot or table created above.
- Read the excerpt from an example BTP and write your own version of a reflection on the results shown in that figure/table.
  - *Yours does not need to be as precise or detailed as many of the examples provided. Just use the text to guide one or two sentences about each item.*
- Once you have answered each of these questions, you should click the `Knit` button at the top of this panel and wait for R Studio to convert your document into an html report.
  - This is your group's finalized **Breeding and Transfer Plan**.
  - You will load your html file into the assignment submission portal on canvas.
- Store the image files created in a location where you can access them later for your online portfolio.
  - Your working directory will contain a series of files ending in `.html`, `.png`, or `.csv`. You may find any of these useful later.
  - *Note that to view the html files, you should double click the file to open it in an internet browser.*

## Demography

### Examples
 
>The Prosimian TAG has set a target population size of 55 animals in the Pygmy Slow Loris SSP population. The managed population has been increasing (λ = 0.96) historically, and has retained 92.39% of its founding gene diversity.


>This SSP species first appeared in AZA facilities in 1968 when a single male was confiscated and transferred to the Honolulu Zoo. From 1968 – 1986, the population size remained low, never exceeding four individuals, and the Honolulu Zoo remained the only holding institution. The current SSP population was founded in 1987 when the San Diego Zoo, Duke Lemur Center, and Cincinnati Zoo imported 29 individuals from Sweden. The first recorded births occurred in 1988 at all three facilities that worked to import animals. The population steadily grew to a peak of 76 individuals by 2011 (Figure 1). This growth can largely be attributed to successful breeding and secondly to a small number of continued imports. Since 2012, the population has experienced a notable decline in size primarily due to insufficient reproduction. The reasons for this low, inconsistent reproduction in recent years are currently unclear, but may be associated with husbandry, particularly diet. However, the population has shown growth over the last five years again and there are enough births to offset deaths in the population.

### Results

```{r, out.width="100%"}
founder.vis
```


```{r, out.width="100%"}
population.text <- paste0("\u03BB = ", round(lambda2, digits = 3))

plot.population.lambda <- add_annotations(
                            plot.population,
                            x            = 0.2,
                            y            = 0.9,
                            xref         = "paper",
                            yref         = "paper",
                            text         = population.text,
                            hovertext    = lambda.hover,
                            showarrow    = FALSE,
                            data         = monthly_counts,
                            textposition = "top left",
                            font         = list(size = 16, style = "italic"),
                            bgcolor      = "#ffffff",
                            bordercolor  = "#000000"
                            )


saveWidget(plot.population.lambda, paste0("PopulationGrowth_", params$group, ".html"))

plot.population.lambda
```

```{r}
pva.summary
```

### Summary

Add your text here.


## Genetics

### Examples

>Genetic values are calculated after incorporating pedigree assumptions and removing excluded individuals. Analysis of the studbook indicates that this SSP is descended from 30 founders with no potential founders remaining (Figure 3, Table 2). The gene diversity of the population is 92%. Based on current founder representations, gene diversity is equivalent to that found in approximately six founders. The current mean kinship in the population is 0.0799; first-cousins have a kinship of 0.0625, which means that the average relationship in the population is slightly closer than that of noninbred first-cousins.

>Population management theory suggests genetic management should strive to maintain thresholds for tolerance of gene diversity loss. The standard goal is 90% gene diversity retention for 100 years. Decreases in gene diversity below 90% of that in the founding population have been associated with increasingly compromised reproduction by, among other factors, lower birth/hatch weights, smaller litter/clutch sizes, and greater neonatal mortality in some species.

>Based on current population parameters, gene diversity is projected to decline to 66% over the next 100 years if the current population grows to the recommended target size of 55 (Table 3, Scenario a). The most effective ways this population can maintain more gene diversity are to have an increasing growth rate (vs. stable) and a larger long-term population size. The effective population size is high and is helping to maintain gene diversity in this population.

### Results

```{r}
plot_pedigrees(ped.living, "Pedigree of Living Population")
```

```{r}
ped.net
```

```{r}
btp.match.plot
```

### Summary

Add your text here.

## Recommendations

### Examples

Table: **NY BRONX**<br>**Bronx Zoo/Wildlife Conservation Society**

|SB ID |Local ID|Sex   |Age  |Disposition  |Location   |Breeding      | With   |
|:----:|:------:|:-----|:---:|:-----------:|:---------:|:------------:|:------:|
|2623  |M14052  |M     |14   |HOLD         |NY BRONX   |BREED WITH    |2640    |
|2640  |M14053  |F     |12   |HOLD         |NY BRONX   |BREED WITH    |2623    |
|2682  |M19007  |M     |7    |RECEIVE FROM |BLOOMINGT  |BREED WITH    |2708    |
|2708  |116283  |F     |4    |RECEIVE FROM |NZP-WASH   |BREED WITH    |2682    |

Table: **NZP-WASH**<br>**Smithsonian National Zoological Park**

|SB ID |Local ID|Sex   |Age  |Disposition  |Location   |Breeding      | With   |
|:----:|:------:|:-----|:---:|:-----------:|:---------:|:------------:|:------:|
|2708  |116283  |4     |14   |SEND TO      |NY BRONX   |BREED WITH    |2682    |
|2715  |116282  |3     |12   |HOLD         |NZP-WASH   |DO NOT BREED  |        |
|2735  |116461  |0     |7    |HOLD         |NZP-WASH   |DO NOT BREED  |        |
|2736  |116462  |0     |4    |HOLD         |NZP-WASH   |DO NOT BREED  |        |

Table: **OMAHA**<br>**Omaha's Henry Doorly Zoo**

|SB ID |Local ID|Sex   |Age  |Disposition  |Location   |Breeding      | With   |
|:----:|:------:|:-----|:---:|:-----------:|:---------:|:------------:|:------:|
|2652  |24485   |M     |11   |HOLD         |OMAHA      |BREED WITH    |2677    |
|2677  |24709   |F     |7    |HOLD         |OMAHA      |BREED WITH    |2652    |


### Results

```{r}
kappa.tri
```

```{r}
pair.vert
```

```{r}
living.summary
```

### Summary

>**Note**: For your summary you should write a few sentences explaining the choice you made. You may use a table format like this, a bulleted list, or a paragraph to present your proposed breeding pair(s).

Add your text here.


